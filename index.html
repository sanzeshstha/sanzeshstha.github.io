<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CyberFlappy - Neon Bird</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        :root {
            --neon-blue: #0ff;
            --neon-pink: #f0f;
            --dark-bg: #0a0a1a;
        }
        
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background-color: var(--dark-bg);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-text-size-adjust: none;
            text-size-adjust: none;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .neon-text {
            text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue), 0 0 15px var(--neon-blue);
        }
        
        .neon-border {
            box-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue), inset 0 0 10px var(--neon-blue);
            border: 1px solid var(--neon-blue);
        }
        
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 95%,
                rgba(0, 255, 255, 0.1) 96%
            );
            background-size: 100% 4px;
            z-index: 2;
            pointer-events: none;
        }
        
        .glitch-effect {
            animation: glitch 1s linear infinite;
        }
        
        @keyframes glitch {
            0% {
                text-shadow: 2px 0 var(--neon-blue), -2px 0 var(--neon-pink);
            }
            25% {
                text-shadow: -2px 0 var(--neon-blue), 2px 0 var(--neon-pink);
            }
            50% {
                text-shadow: 2px 0 var(--neon-pink), -2px 0 var(--neon-blue);
            }
            75% {
                text-shadow: -2px 0 var(--neon-pink), 2px 0 var(--neon-blue);
            }
            100% {
                text-shadow: 2px 0 var(--neon-blue), -2px 0 var(--neon-pink);
            }
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .game-title {
                font-size: 2.5rem !important;
                margin-bottom: 1.5rem !important;
            }
            .game-instructions {
                font-size: 1rem !important;
                padding: 1rem !important;
                margin-bottom: 1.5rem !important;
            }
            .game-button {
                padding: 0.75rem 1.5rem !important;
                font-size: 1rem !important;
            }
            #scoreDisplay {
                font-size: 1.25rem !important;
                top: 1rem !important;
                left: 1rem !important;
            }
        }
        
        /* Prevent zoom on double-tap */
        * {
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="bg-black text-white relative h-screen w-screen">
    <div class="scanlines"></div>
    
    <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center z-10 bg-black bg-opacity-80">
        <h1 class="game-title text-5xl md:text-7xl mb-8 neon-text glitch-effect">CYBER<span class="text-pink-500">FLAPPY</span></h1>
        <div class="game-instructions neon-border p-6 rounded-lg mb-8 bg-gray-900 bg-opacity-70">
            <p class="text-xl mb-4">Use SPACE or TAP to fly</p>
            <p class="text-sm text-gray-400">Avoid the neon pipes</p>
        </div>
        <button id="startButton" class="game-button px-8 py-4 bg-purple-800 hover:bg-purple-700 text-white font-bold rounded-lg neon-border transition-all hover:scale-105">
            START GAME
        </button>
        <div class="mt-8 text-xs text-gray-500">
            <p>High Score: <span id="highScoreDisplay">0</span></p>
        </div>
    </div>
    
    <div id="gameOverScreen" class="absolute inset-0 hidden flex-col items-center justify-center z-10 bg-black bg-opacity-80">
        <h1 class="game-title text-5xl md:text-7xl mb-8 neon-text text-red-500">GAME OVER</h1>
        <div class="game-instructions neon-border p-6 rounded-lg mb-8 bg-gray-900 bg-opacity-70">
            <p class="text-xl mb-2">Score: <span id="finalScore" class="text-green-400">0</span></p>
            <p class="text-sm">High Score: <span id="finalHighScore" class="text-yellow-400">0</span></p>
        </div>
        <button id="restartButton" class="game-button px-8 py-4 bg-purple-800 hover:bg-purple-700 text-white font-bold rounded-lg neon-border transition-all hover:scale-105">
            TRY AGAIN
        </button>
    </div>
    
    <div id="scoreDisplay" class="absolute top-4 left-4 text-2xl neon-text hidden z-10">
        Score: <span id="currentScore">0</span>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <script>
        // Use modern JavaScript features with fallbacks
        document.addEventListener('DOMContentLoaded', () => {
            // Game elements
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d', { alpha: false });
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const currentScoreDisplay = document.getElementById('currentScore');
            const finalScoreDisplay = document.getElementById('finalScore');
            const highScoreDisplay = document.getElementById('highScoreDisplay');
            const finalHighScoreDisplay = document.getElementById('finalHighScore');
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            
            // Set canvas size with device pixel ratio support
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
            }
            
            // Initial resize and on window resize
            resizeCanvas();
            window.addEventListener('resize', () => {
                resizeCanvas();
                if (gameRunning) {
                    drawBackground();
                    drawPipes();
                    drawBird();
                }
            });
            
            // Game variables
            let score = 0;
            let highScore = localStorage.getItem('cyberFlappyHighScore') || 0;
            let gameRunning = false;
            let animationFrameId;
            let lastPipeTime = 0;
            let pipeInterval = 2000; // ms between pipes
            
            // Update high score display
            highScoreDisplay.textContent = highScore;
            
            // Bird properties (scaled based on screen size)
            const getBirdSize = () => Math.max(30, Math.min(40, canvas.width / 10));
            const bird = {
                x: 100,
                y: canvas.height / 2,
                get width() { return getBirdSize(); },
                get height() { return getBirdSize() * 0.75; },
                velocity: 0,
                gravity: 0.5,
                jumpForce: -10,
                color: '#0ff'
            };
            
            // Pipes properties (scaled based on screen size)
            const getPipeWidth = () => Math.max(60, Math.min(80, canvas.width / 8));
            const getPipeGap = () => Math.max(180, Math.min(220, canvas.height / 3));
            const pipes = {
                get width() { return getPipeWidth(); },
                get gap() { return getPipeGap(); },
                speed: 3,
                list: [],
                color: '#f0f'
            };
            
            // Background elements
            const background = {
                buildings: [],
                stars: [],
                color: '#0a0a1a'
            };
            
            // Create initial background buildings
            function createBuildings() {
                background.buildings = [];
                const buildingCount = Math.max(5, Math.floor(canvas.width / 150));
                for (let i = 0; i < buildingCount; i++) {
                    background.buildings.push({
                        x: i * (canvas.width / buildingCount),
                        width: canvas.width / buildingCount,
                        height: Math.random() * 200 + 100,
                        color: `hsl(${Math.random() * 60 + 240}, 80%, 30%)`
                    });
                }
            }
            
            // Create stars
            function createStars() {
                background.stars = [];
                const starCount = Math.max(50, Math.floor(canvas.width * canvas.height / 5000));
                for (let i = 0; i < starCount; i++) {
                    background.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2 + 1,
                        twinkle: Math.random() * 5
                    });
                }
            }
            
            // Draw neon glow effect
            function drawNeonGlow(x, y, width, height, color, blur = 20) {
                ctx.save();
                ctx.shadowColor = color;
                ctx.shadowBlur = blur;
                ctx.fillStyle = color;
                ctx.fillRect(x, y, width, height);
                ctx.restore();
            }
            
            // Draw bird
            function drawBird() {
                // Neon glow
                drawNeonGlow(bird.x - 5, bird.y - 5, bird.width + 10, bird.height + 10, bird.color);
                
                // Bird body
                ctx.fillStyle = '#000';
                ctx.fillRect(bird.x, bird.y, bird.width, bird.height);
                
                // Bird eye
                ctx.fillStyle = '#fff';
                ctx.fillRect(bird.x + bird.width - 15, bird.y + 5, 10, 10);
                
                // Bird beak
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.moveTo(bird.x + bird.width, bird.y + bird.height / 2);
                ctx.lineTo(bird.x + bird.width + 15, bird.y + bird.height / 2);
                ctx.lineTo(bird.x + bird.width, bird.y + bird.height / 2 + 10);
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw pipes
            function drawPipes() {
                pipes.list.forEach(pipe => {
                    // Top pipe
                    drawNeonGlow(pipe.x - 5, 0, pipes.width + 10, pipe.topHeight + 10, pipes.color);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(pipe.x, 0, pipes.width, pipe.topHeight);
                    
                    // Bottom pipe
                    drawNeonGlow(pipe.x - 5, pipe.bottomY - 5, pipes.width + 10, pipe.bottomHeight + 10, pipes.color);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(pipe.x, pipe.bottomY, pipes.width, pipe.bottomHeight);
                    
                    // Pipe decorations
                    ctx.fillStyle = '#0ff';
                    // Top pipe decoration
                    ctx.fillRect(pipe.x, pipe.topHeight - 20, pipes.width, 5);
                    // Bottom pipe decoration
                    ctx.fillRect(pipe.x, pipe.bottomY, pipes.width, 5);
                });
            }
            
            // Draw background
            function drawBackground() {
                // Clear canvas
                ctx.fillStyle = background.color;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw stars
                ctx.fillStyle = '#fff';
                background.stars.forEach(star => {
                    const brightness = 0.7 + Math.sin(Date.now() / 1000 + star.twinkle) * 0.3;
                    ctx.globalAlpha = brightness;
                    ctx.fillRect(star.x, star.y, star.size, star.size);
                });
                ctx.globalAlpha = 1;
                
                // Draw buildings
                background.buildings.forEach(building => {
                    // Building glow
                    drawNeonGlow(building.x - 5, canvas.height - building.height - 5, building.width + 10, building.height + 10, building.color, 15);
                    
                    // Building body
                    ctx.fillStyle = '#000';
                    ctx.fillRect(building.x, canvas.height - building.height, building.width, building.height);
                    
                    // Building windows
                    ctx.fillStyle = '#0ff';
                    const windowRows = Math.floor(building.height / 30);
                    const windowCols = Math.floor(building.width / 20);
                    const windowPadding = 5;
                    
                    for (let row = 0; row < windowRows; row++) {
                        for (let col = 0; col < windowCols; col++) {
                            if (Math.random() > 0.3) { // Randomly turn some windows on/off
                                ctx.fillRect(
                                    building.x + col * 20 + windowPadding,
                                    canvas.height - building.height + row * 30 + windowPadding,
                                    10, 10
                                );
                            }
                        }
                    }
                });
            }
            
            // Update bird position
            function updateBird() {
                bird.velocity += bird.gravity;
                bird.y += bird.velocity;
                
                // Check if bird hits the ground or ceiling
                if (bird.y + bird.height > canvas.height || bird.y < 0) {
                    gameOver();
                }
            }
            
            // Make bird jump
            function jump() {
                if (gameRunning) {
                    bird.velocity = bird.jumpForce;
                    
                    // Play jump sound (using Web Audio API for better mobile support)
                    try {
                        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioCtx.createOscillator();
                        const gainNode = audioCtx.createGain();
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 800;
                        gainNode.gain.value = 0.1;
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioCtx.destination);
                        
                        oscillator.start();
                        oscillator.stop(audioCtx.currentTime + 0.1);
                    } catch (e) {
                        console.log('Audio error:', e);
                    }
                }
            }
            
            // Generate new pipes
            function generatePipes() {
                const minHeight = 50;
                const maxHeight = canvas.height - pipes.gap - minHeight;
                const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
                
                pipes.list.push({
                    x: canvas.width,
                    topHeight: topHeight,
                    bottomY: topHeight + pipes.gap,
                    bottomHeight: canvas.height - (topHeight + pipes.gap),
                    passed: false
                });
            }
            
            // Update pipes
            function updatePipes() {
                const now = Date.now();
                
                // Generate new pipes based on time interval
                if (pipes.list.length === 0 || (now - lastPipeTime > pipeInterval && pipes.list[pipes.list.length - 1].x < canvas.width - 200)) {
                    generatePipes();
                    lastPipeTime = now;
                    
                    // Increase difficulty slightly
                    pipeInterval = Math.max(1000, pipeInterval - 10);
                    pipes.speed = Math.min(6, pipes.speed + 0.01);
                }
                
                // Move pipes and check for collisions
                for (let i = pipes.list.length - 1; i >= 0; i--) {
                    pipes.list[i].x -= pipes.speed;
                    
                    // Check for collision with bird
                    if (
                        bird.x + bird.width > pipes.list[i].x &&
                        bird.x < pipes.list[i].x + pipes.width &&
                        (bird.y < pipes.list[i].topHeight || bird.y + bird.height > pipes.list[i].bottomY)
                    ) {
                        gameOver();
                    }
                    
                    // Check if bird passed the pipe
                    if (!pipes.list[i].passed && bird.x > pipes.list[i].x + pipes.width) {
                        pipes.list[i].passed = true;
                        score++;
                        currentScoreDisplay.textContent = score;
                        
                        // Play score sound
                        try {
                            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioCtx.createOscillator();
                            const gainNode = audioCtx.createGain();
                            
                            oscillator.type = 'square';
                            oscillator.frequency.value = 1200;
                            gainNode.gain.value = 0.1;
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioCtx.destination);
                            
                            oscillator.start();
                            oscillator.stop(audioCtx.currentTime + 0.05);
                        } catch (e) {
                            console.log('Audio error:', e);
                        }
                    }
                    
                    // Remove pipes that are off screen
                    if (pipes.list[i].x + pipes.width < 0) {
                        pipes.list.splice(i, 1);
                    }
                }
            }
            
            // Update background
            function updateBackground() {
                // Move buildings
                background.buildings.forEach(building => {
                    building.x -= pipes.speed / 2;
                    if (building.x + building.width < 0) {
                        building.x = canvas.width;
                        building.height = Math.random() * 200 + 100;
                        building.color = `hsl(${Math.random() * 60 + 240}, 80%, 30%)`;
                    }
                });
                
                // Twinkle stars
                background.stars.forEach(star => {
                    star.x -= pipes.speed / 10;
                    if (star.x < 0) {
                        star.x = canvas.width;
                        star.y = Math.random() * canvas.height;
                    }
                });
            }
            
            // Game over
            function gameOver() {
                if (!gameRunning) return;
                
                gameRunning = false;
                cancelAnimationFrame(animationFrameId);
                
                // Play game over sound
                try {
                    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                    gainNode.gain.value = 0.1;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.5);
                } catch (e) {
                    console.log('Audio error:', e);
                }
                
                // Update high score
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('cyberFlappyHighScore', highScore);
                }
                
                // Show game over screen
                finalScoreDisplay.textContent = score;
                finalHighScoreDisplay.textContent = highScore;
                gameOverScreen.classList.remove('hidden');
                scoreDisplay.classList.add('hidden');
            }
            
            // Game loop optimized for mobile
            function gameLoop(timestamp) {
                if (!gameRunning) return;
                
                drawBackground();
                updateBird();
                updatePipes();
                updateBackground();
                drawPipes();
                drawBird();
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            // Start game
            function startGame() {
                // Reset game state
                score = 0;
                currentScoreDisplay.textContent = score;
                bird.y = canvas.height / 2;
                bird.velocity = 0;
                pipes.list = [];
                lastPipeTime = Date.now();
                pipeInterval = 2000;
                pipes.speed = 3;
                
                // Create background
                createBuildings();
                createStars();
                
                // Show game elements
                startScreen.classList.add('hidden');
                gameOverScreen.classList.add('hidden');
                scoreDisplay.classList.remove('hidden');
                
                // Start game
                gameRunning = true;
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            // Event listeners with passive options for better mobile performance
            startButton.addEventListener('click', startGame, { passive: true });
            restartButton.addEventListener('click', startGame, { passive: true });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    jump();
                }
            }, { passive: false });
            
            // Touch controls
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                jump();
            }, { passive: false });
            
            // Mouse controls
            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                jump();
            }, { passive: false });
            
            // Initial setup
            drawBackground();
            createBuildings();
            createStars();
            
            // Handle mobile browser address bar showing/hiding
            window.addEventListener('resize', () => {
                if (document.activeElement) {
                    document.activeElement.blur();
                }
            });
            
            // Prevent pull-to-refresh on mobile
            document.body.addEventListener('touchmove', (e) => {
                if (gameRunning) {
                    e.preventDefault();
                }
            }, { passive: false });
        });
    </script>
</body>
</html>